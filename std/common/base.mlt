define apply [R..., S..., T, +P] (T, (R..., T -> S... +P) -> (R... -> S... +P)) {
  -> x, f;
  { x f call }
}

define both [A, B, C, D] (A, B, (A -> C), (B -> D) -> C, D) {
  -> x, y, f, g;
  x f call -> a;
  y g call -> b;
  a b
}

define both_to [A, B, C] (A, (A -> B), (A -> C) -> B, C) {
  -> x, f, g;
  x f call -> a;
  x g call -> b;
  a b
}

define compose [R..., S..., T...] ((R... -> S...), (S... -> T...) -> (R... -> T...)) {
  -> f, g;
  { f call g call }
}

define dip [R..., S..., T] (R..., T, (R... -> S...) -> S..., T) {
  -> x;
  call x
}

define drop2 [A, B] (A, B ->) {
  -> _;
  -> _;
}

define dup [T] (T -> T, T) {
  -> x;
  x x
}

define dup2 [A, B] (A, B -> A, B, A, B) {
  -> x, y;
  x y x y
}

define fix [R..., S...] (R..., (R..., (R... -> S...) -> S...) -> S...) {
  -> f;
  { f fix } f call
}

define function [T] (T -> (-> T)) {
  -> x;
  { x }
}

define id [T] (T -> T) {}

define swapped [R..., S..., A, B] ((R..., A, B -> S...) -> (R..., B, A -> S...)) {
  \swap swap compose
}

define to_both [A, B] (A, A, (A -> B) -> B, B) {
  -> x, y, f;
  x f call -> a;
  y f call -> b;
  a b
}

about fix {
  docs {
    """
    Computes the least fixed point of a function. Can be used to write recursive
    definitions without explicit recursion, e.g.:

        // Compute the factorial of 5.
        5 {
          -> n, rec;
          if (n <= 0):
            1
          else:
            (n - 1) rec call * n
        } fix
    """
  }
}

about apply {
  docs {
    "Partially applies the topmost argument of a function."
  }
}
